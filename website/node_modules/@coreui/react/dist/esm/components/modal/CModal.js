import { __rest, __assign } from '../../node_modules/tslib/tslib.es6.js';
import React__default, { createContext, forwardRef, useRef, useState, useEffect, useLayoutEffect, useCallback } from 'react';
import { createPortal } from 'react-dom';
import '../../node_modules/prop-types/index.js';
import classNames from '../../node_modules/classnames/index.js';
import '../../node_modules/react-transition-group/esm/CSSTransition.js';
import '../../node_modules/react-transition-group/esm/ReplaceTransition.js';
import '../../node_modules/react-transition-group/esm/SwitchTransition.js';
import '../../node_modules/react-transition-group/esm/TransitionGroup.js';
import Transition from '../../node_modules/react-transition-group/esm/Transition.js';
import { useForkedRef } from '../../utils/hooks/useForkedRef.js';
import { CBackdrop } from '../backdrop/CBackdrop.js';
import { CModalContent } from './CModalContent.js';
import { CModalDialog } from './CModalDialog.js';
import { exports as propTypesExports } from '../../_virtual/index.js';

var CModalContext = createContext({});
var CModal = forwardRef(function (_a, ref) {
    var children = _a.children, alignment = _a.alignment, _b = _a.backdrop, backdrop = _b === void 0 ? true : _b, className = _a.className, _c = _a.duration, duration = _c === void 0 ? 150 : _c, fullscreen = _a.fullscreen, _d = _a.keyboard, keyboard = _d === void 0 ? true : _d, onClose = _a.onClose, onClosePrevented = _a.onClosePrevented, onShow = _a.onShow, _e = _a.portal, portal = _e === void 0 ? true : _e, scrollable = _a.scrollable, size = _a.size, _f = _a.transition, transition = _f === void 0 ? true : _f, _g = _a.unmountOnClose, unmountOnClose = _g === void 0 ? true : _g, visible = _a.visible, rest = __rest(_a, ["children", "alignment", "backdrop", "className", "duration", "fullscreen", "keyboard", "onClose", "onClosePrevented", "onShow", "portal", "scrollable", "size", "transition", "unmountOnClose", "visible"]);
    var modalRef = useRef(null);
    var modalContentRef = useRef(null);
    var forkedRef = useForkedRef(ref, modalRef);
    var _h = useState(visible), _visible = _h[0], setVisible = _h[1];
    var _j = useState(false), staticBackdrop = _j[0], setStaticBackdrop = _j[1];
    useEffect(function () {
        setVisible(visible);
    }, [visible]);
    var contextValues = {
        visible: _visible,
        setVisible: setVisible,
    };
    useEffect(function () {
        modalRef.current && modalRef.current.addEventListener('click', handleClickOutside);
        modalRef.current && modalRef.current.addEventListener('keyup', handleKeyDown);
        return function () {
            modalRef.current && modalRef.current.removeEventListener('click', handleClickOutside);
            modalRef.current && modalRef.current.removeEventListener('keyup', handleKeyDown);
        };
    }, [_visible]);
    var handleDismiss = function () {
        if (backdrop === 'static') {
            return setStaticBackdrop(true);
        }
        return onClose && onClose();
    };
    useLayoutEffect(function () {
        onClosePrevented && onClosePrevented();
        setTimeout(function () { return setStaticBackdrop(false); }, duration);
    }, [staticBackdrop]);
    var getTransitionClass = function (state) {
        return state === 'entering'
            ? 'd-block'
            : state === 'entered'
                ? 'show d-block'
                : state === 'exiting'
                    ? 'd-block'
                    : '';
    };
    var _className = classNames('modal', {
        'modal-static': staticBackdrop,
        fade: transition,
    }, className);
    // Set focus to modal after open
    useLayoutEffect(function () {
        if (_visible) {
            document.body.classList.add('modal-open');
            if (backdrop) {
                document.body.style.overflow = 'hidden';
                document.body.style.paddingRight = '0px';
            }
            setTimeout(function () {
                var _a;
                (_a = modalRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            }, !transition ? 0 : duration);
        }
        else {
            document.body.classList.remove('modal-open');
            if (backdrop) {
                document.body.style.removeProperty('overflow');
                document.body.style.removeProperty('padding-right');
            }
        }
        return function () {
            document.body.classList.remove('modal-open');
            if (backdrop) {
                document.body.style.removeProperty('overflow');
                document.body.style.removeProperty('padding-right');
            }
        };
    }, [_visible]);
    var handleClickOutside = function (event) {
        if (modalContentRef.current &&
            !modalContentRef.current.contains(event.target)) {
            handleDismiss();
        }
    };
    var handleKeyDown = useCallback(function (event) {
        if (event.key === 'Escape' && keyboard) {
            return handleDismiss();
        }
    }, [modalRef, handleDismiss]);
    var modal = function (ref, transitionClass) {
        return (React__default.createElement(CModalContext.Provider, { value: contextValues },
            React__default.createElement("div", { className: classNames(_className, transitionClass), tabIndex: -1, role: "dialog", ref: ref },
                React__default.createElement(CModalDialog, { alignment: alignment, fullscreen: fullscreen, scrollable: scrollable, size: size },
                    React__default.createElement(CModalContent, __assign({}, rest, { ref: modalContentRef }), children)))));
    };
    return (React__default.createElement(React__default.Fragment, null,
        React__default.createElement(Transition, { in: _visible, mountOnEnter: true, nodeRef: modalRef, onEnter: onShow, onExit: onClose, unmountOnExit: unmountOnClose, timeout: !transition ? 0 : duration }, function (state) {
            var transitionClass = getTransitionClass(state);
            return typeof window !== 'undefined' && portal
                ? createPortal(modal(forkedRef, transitionClass), document.body)
                : modal(forkedRef, transitionClass);
        }),
        typeof window !== 'undefined' && portal
            ? backdrop && createPortal(React__default.createElement(CBackdrop, { visible: _visible }), document.body)
            : backdrop && React__default.createElement(CBackdrop, { visible: _visible })));
});
CModal.propTypes = {
    alignment: propTypesExports.oneOf(['top', 'center']),
    backdrop: propTypesExports.oneOfType([propTypesExports.bool, propTypesExports.oneOf(['static'])]),
    children: propTypesExports.node,
    className: propTypesExports.string,
    duration: propTypesExports.number,
    fullscreen: propTypesExports.oneOfType([
        propTypesExports.bool,
        propTypesExports.oneOf(['sm', 'md', 'lg', 'xl', 'xxl']),
    ]),
    keyboard: propTypesExports.bool,
    onClose: propTypesExports.func,
    onClosePrevented: propTypesExports.func,
    onShow: propTypesExports.func,
    portal: propTypesExports.bool,
    scrollable: propTypesExports.bool,
    size: propTypesExports.oneOf(['sm', 'lg', 'xl']),
    transition: propTypesExports.bool,
    unmountOnClose: propTypesExports.bool,
    visible: propTypesExports.bool,
};
CModal.displayName = 'CModal';

export { CModal, CModalContext };
//# sourceMappingURL=CModal.js.map
