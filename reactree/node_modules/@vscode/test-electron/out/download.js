"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.downloadAndUnzipVSCode = exports.download = exports.defaultCachePath = void 0;
const cp = require("child_process");
const fs = require("fs");
const os_1 = require("os");
const path = require("path");
const stream_1 = require("stream");
const unzipper_1 = require("unzipper");
const util_1 = require("util");
const del = require("./del");
const progress_1 = require("./progress");
const request = require("./request");
const util_2 = require("./util");
const extensionRoot = process.cwd();
const vscodeStableReleasesAPI = `https://update.code.visualstudio.com/api/releases/stable`;
const vscodeInsiderCommitsAPI = (platform) => `https://update.code.visualstudio.com/api/commits/insider/${platform}`;
const DOWNLOAD_ATTEMPTS = 3;
async function fetchLatestStableVersion(timeout) {
    const versions = await request.getJSON(vscodeStableReleasesAPI, timeout);
    if (!versions || !Array.isArray(versions) || !versions[0]) {
        throw Error('Failed to get latest VS Code version');
    }
    return versions[0];
}
async function isValidVersion(version, platform, timeout) {
    if (version === 'insiders') {
        return true;
    }
    const stableVersionNumbers = await request.getJSON(vscodeStableReleasesAPI, timeout);
    if (stableVersionNumbers.includes(version)) {
        return true;
    }
    const insiderCommits = await request.getJSON(vscodeInsiderCommitsAPI(platform), timeout);
    if (insiderCommits.includes(version)) {
        return true;
    }
}
/**
 * Download a copy of VS Code archive to `.vscode-test`.
 *
 * @param version The version of VS Code to download such as '1.32.0'. You can also use
 * `'stable'` for downloading latest stable release.
 * `'insiders'` for downloading latest Insiders.
 */
async function downloadVSCodeArchive(options) {
    var _a, _b;
    if (!fs.existsSync(options.cachePath)) {
        fs.mkdirSync(options.cachePath);
    }
    const timeout = options.timeout;
    const downloadUrl = util_2.getVSCodeDownloadUrl(options.version, options.platform);
    (_a = options.reporter) === null || _a === void 0 ? void 0 : _a.report({ stage: progress_1.ProgressReportStage.ResolvingCDNLocation, url: downloadUrl });
    const res = await request.getStream(downloadUrl, timeout);
    if (res.statusCode !== 302) {
        throw 'Failed to get VS Code archive location';
    }
    const url = res.headers.location;
    if (!url) {
        throw 'Failed to get VS Code archive location';
    }
    res.destroy();
    const download = await request.getStream(url, timeout);
    const totalBytes = Number(download.headers['content-length']);
    const contentType = download.headers['content-type'];
    const isZip = contentType ? contentType === 'application/zip' : url.endsWith('.zip');
    const timeoutCtrl = new request.TimeoutController(timeout);
    (_b = options.reporter) === null || _b === void 0 ? void 0 : _b.report({ stage: progress_1.ProgressReportStage.Downloading, url, bytesSoFar: 0, totalBytes });
    let bytesSoFar = 0;
    download.on('data', chunk => {
        var _a;
        bytesSoFar += chunk.length;
        timeoutCtrl.touch();
        (_a = options.reporter) === null || _a === void 0 ? void 0 : _a.report({ stage: progress_1.ProgressReportStage.Downloading, url, bytesSoFar, totalBytes });
    });
    download.on('end', () => {
        var _a;
        timeoutCtrl.dispose();
        (_a = options.reporter) === null || _a === void 0 ? void 0 : _a.report({ stage: progress_1.ProgressReportStage.Downloading, url, bytesSoFar: totalBytes, totalBytes });
    });
    timeoutCtrl.signal.addEventListener('abort', () => {
        download.emit('error', new request.TimeoutError(timeout));
        download.destroy();
    });
    return { stream: download, format: isZip ? 'zip' : 'tgz' };
}
/**
 * Unzip a .zip or .tar.gz VS Code archive stream.
 */
async function unzipVSCode(reporter, extractDir, extractSync, stream, format) {
    const stagingFile = path.join(os_1.tmpdir(), `vscode-test-${Date.now()}.zip`);
    if (format === 'zip') {
        // note: this used to use Expand-Archive, but this caused a failure
        // on longer file paths on windows. Instead use unzipper, which does
        // not have this limitation.
        //
        // However it has problems that prevent it working on OSX:
        // - https://github.com/ZJONSSON/node-unzipper/issues/216 (avoidable)
        // - https://github.com/ZJONSSON/node-unzipper/issues/115 (not avoidable)
        if (process.platform === 'win32' && extractSync) {
            try {
                await util_1.promisify(stream_1.pipeline)(stream, fs.createWriteStream(stagingFile));
                reporter.report({ stage: progress_1.ProgressReportStage.ExtractingSynchonrously });
                await spawnDecompressorChild('powershell.exe', [
                    '-NoProfile', '-ExecutionPolicy', 'Bypass', '-NonInteractive', '-NoLogo',
                    '-Command', `Microsoft.PowerShell.Archive\\Expand-Archive -Path "${stagingFile}" -DestinationPath "${extractDir}"`
                ]);
            }
            finally {
                fs.unlink(stagingFile, () => undefined);
            }
        }
        else if (process.platform !== 'darwin' && !extractSync) {
            await new Promise((resolve, reject) => stream
                .on('error', reject)
                .pipe(unzipper_1.Extract({ path: extractDir }))
                .on('close', resolve)
                .on('error', reject));
        }
        else { // darwin or *nix sync
            try {
                await util_1.promisify(stream_1.pipeline)(stream, fs.createWriteStream(stagingFile));
                reporter.report({ stage: progress_1.ProgressReportStage.ExtractingSynchonrously });
                await spawnDecompressorChild('unzip', ['-q', stagingFile, '-d', extractDir]);
            }
            finally {
                fs.unlink(stagingFile, () => undefined);
            }
        }
    }
    else {
        // tar does not create extractDir by default
        if (!fs.existsSync(extractDir)) {
            fs.mkdirSync(extractDir);
        }
        await spawnDecompressorChild('tar', ['-xzf', '-', '--strip-components=1', '-C', extractDir], stream);
    }
}
function spawnDecompressorChild(command, args, input) {
    return new Promise((resolve, reject) => {
        const child = cp.spawn(command, args, { stdio: 'pipe' });
        if (input) {
            input.on('error', reject);
            input.pipe(child.stdin);
        }
        child.stderr.pipe(process.stderr);
        child.stdout.pipe(process.stdout);
        child.on('error', reject);
        child.on('exit', code => code === 0 ? resolve() : reject(new Error(`Failed to unzip archive, exited with ${code}`)));
    });
}
exports.defaultCachePath = path.resolve(extensionRoot, '.vscode-test');
/**
 * Download and unzip a copy of VS Code.
 * @returns Promise of `vscodeExecutablePath`.
 */
async function download(options = {}) {
    let version = options === null || options === void 0 ? void 0 : options.version;
    const { platform = util_2.systemDefaultPlatform, cachePath = exports.defaultCachePath, reporter = new progress_1.ConsoleReporter(process.stdout.isTTY), extractSync = false, timeout = 15000, } = options;
    if (version) {
        if (version === 'stable') {
            version = await fetchLatestStableVersion(timeout);
        }
        else {
            /**
             * Only validate version against server when no local download that matches version exists
             */
            if (!fs.existsSync(path.resolve(cachePath, `vscode-${platform}-${version}`))) {
                if (!(await isValidVersion(version, platform, timeout))) {
                    throw Error(`Invalid version ${version}`);
                }
            }
        }
    }
    else {
        version = await fetchLatestStableVersion(timeout);
    }
    reporter.report({ stage: progress_1.ProgressReportStage.ResolvedVersion, version });
    const downloadedPath = path.resolve(cachePath, `vscode-${platform}-${version}`);
    if (fs.existsSync(downloadedPath)) {
        if (version === 'insiders') {
            reporter.report({ stage: progress_1.ProgressReportStage.FetchingInsidersMetadata });
            const { version: currentHash, date: currentDate } = util_2.insidersDownloadDirMetadata(downloadedPath, platform);
            const { version: latestHash, timestamp: latestTimestamp } = await util_2.getLatestInsidersMetadata(util_2.systemDefaultPlatform);
            if (currentHash === latestHash) {
                reporter.report({ stage: progress_1.ProgressReportStage.FoundMatchingInstall, downloadedPath });
                return Promise.resolve(util_2.insidersDownloadDirToExecutablePath(downloadedPath, platform));
            }
            else {
                try {
                    reporter.report({
                        stage: progress_1.ProgressReportStage.ReplacingOldInsiders,
                        downloadedPath,
                        oldDate: currentDate,
                        oldHash: currentHash,
                        newDate: new Date(latestTimestamp),
                        newHash: latestHash,
                    });
                    await del.rmdir(downloadedPath);
                }
                catch (err) {
                    reporter.error(err);
                    throw Error(`Failed to remove outdated Insiders at ${downloadedPath}.`);
                }
            }
        }
        else if (util_2.isStableVersionIdentifier(version)) {
            reporter.report({ stage: progress_1.ProgressReportStage.FoundMatchingInstall, downloadedPath });
            return Promise.resolve(util_2.downloadDirToExecutablePath(downloadedPath, platform));
        }
        else {
            reporter.report({ stage: progress_1.ProgressReportStage.FoundMatchingInstall, downloadedPath });
            return Promise.resolve(util_2.insidersDownloadDirToExecutablePath(downloadedPath, platform));
        }
    }
    for (let i = 0;; i++) {
        try {
            const { stream, format } = await downloadVSCodeArchive({ version, platform, cachePath, reporter, timeout });
            await unzipVSCode(reporter, downloadedPath, extractSync, stream, format);
            reporter.report({ stage: progress_1.ProgressReportStage.NewInstallComplete, downloadedPath });
            break;
        }
        catch (error) {
            if (i++ < DOWNLOAD_ATTEMPTS) {
                reporter.report({ stage: progress_1.ProgressReportStage.Retrying, attempt: i, error: error, totalAttempts: DOWNLOAD_ATTEMPTS });
            }
            else {
                reporter.error(error);
                throw Error(`Failed to download and unzip VS Code ${version}`);
            }
        }
    }
    reporter.report({ stage: progress_1.ProgressReportStage.NewInstallComplete, downloadedPath });
    if (util_2.isStableVersionIdentifier(version)) {
        return util_2.downloadDirToExecutablePath(downloadedPath, platform);
    }
    else {
        return util_2.insidersDownloadDirToExecutablePath(downloadedPath, platform);
    }
}
exports.download = download;
async function downloadAndUnzipVSCode(versionOrOptions, platform, reporter, extractSync) {
    return await download(typeof versionOrOptions === 'object'
        ? versionOrOptions
        : { version: versionOrOptions, platform, reporter, extractSync });
}
exports.downloadAndUnzipVSCode = downloadAndUnzipVSCode;
