"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const os_1 = require("os");
const path_1 = require("path");
const vitest_1 = require("vitest");
const download_1 = require("./download");
const progress_1 = require("./progress");
const util_1 = require("./util");
const platforms = ['darwin', 'darwin-arm64', 'win32-archive', 'win32-x64-archive', 'linux-x64', 'linux-arm64', 'linux-armhf'];
vitest_1.describe('sane downloads', () => {
    const testTempDir = path_1.join(os_1.tmpdir(), 'vscode-test-download');
    vitest_1.beforeAll(async () => {
        await fs_1.promises.mkdir(testTempDir, { recursive: true });
    });
    for (const platform of platforms) {
        vitest_1.test.concurrent(platform, async () => {
            const location = await download_1.downloadAndUnzipVSCode({
                platform,
                version: 'stable',
                cachePath: testTempDir,
                reporter: new progress_1.SilentReporter(),
            });
            if (!fs_1.existsSync(location)) {
                throw new Error(`expected ${location} to exist for ${platform}`);
            }
            const exePath = util_1.resolveCliPathFromVSCodeExecutablePath(location, platform);
            if (!fs_1.existsSync(exePath)) {
                throw new Error(`expected ${exePath} to from ${location}`);
            }
            if (platform === util_1.systemDefaultPlatform) {
                const version = child_process_1.spawnSync(exePath, ['--version']);
                vitest_1.expect(version.status).to.equal(0);
                vitest_1.expect(version.stdout.toString().trim()).to.not.be.empty;
            }
        });
    }
    vitest_1.afterAll(async () => {
        try {
            await fs_1.promises.rmdir(testTempDir, { recursive: true });
        }
        catch {
            // ignored
        }
    });
});
